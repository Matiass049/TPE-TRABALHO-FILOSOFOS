import threading    
import time
import random

# TPE-TRABALHO-FILOSOFO
# Simulação de Cluster com Prevenção de Deadlock

class ControladorCluster:
    def __init__(self):
        # Criação das 5 Interfaces de Barramento (antigos garfos/hashis)
        # Usamos Semáforos (Locks) para garantir exclusão mútua
        self.interfaces_io = [threading.Lock() for _ in range(5)]

    def iniciar_cluster(self):
        print(f"--- INICIANDO CLUSTER (5 NÚCLEOS) ---")
        nucleos = []
        for i in range(5):
            # Instancia 5 threads (Núcleos de Processamento)
            nucleo = NucleoProcessamento(id_nucleo=i, controlador=self)
            nucleos.append(nucleo)
            nucleo.start()

        # Mantém o script rodando
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n--- DESLIGANDO CLUSTER ---")

class NucleoProcessamento(threading.Thread):
    def __init__(self, id_nucleo, controlador):
        super().__init__()
        self.id = id_nucleo
        self.controlador = controlador
        # Define vizinhos baseados na topologia circular 
        self.id_interface_esq = id_nucleo
        self.id_interface_dir = (id_nucleo + 1) % 5
        self.daemon = True  # Permite que o programa feche quando o principal fechar

    def computacao_ociosa(self):
        """Estado: Pensando"""
        print(f"[Núcleo {self.id}] STATUS: Executando cálculos locais (Pensando)...")
        time.sleep(random.uniform(1, 3))

    def solicitar_acesso_io(self):
        """Estado: Tentando Comer (Entrar na Região Crítica)"""
        print(f"[Núcleo {self.id}] IRQ: Requisitando acesso a barramentos...")

        # --- INOVAÇÃO: ALGORITMO DE HIERARQUIA DE RECURSOS ---
        # Para evitar Deadlock, ordenamos a aquisição pelo ID da interface.
        # Sempre pega o menor ID primeiro.
        id_primeiro_lock = min(self.id_interface_esq, self.id_interface_dir)
        id_segundo_lock = max(self.id_interface_esq, self.id_interface_dir)

        interface_primaria = self.controlador.interfaces_io[id_primeiro_lock]
        interface_secundaria = self.controlador.interfaces_io[id_segundo_lock]

        # 1. Tenta adquirir o lock de menor índice primeiro
        interface_primaria.acquire()
        
        # 2. Tenta adquirir o lock de maior índice
        interface_secundaria.acquire()
        
        # Se chegou aqui, tem os dois recursos.
        print(f"[Núcleo {self.id}] BLOQUEIO: Interfaces {id_primeiro_lock} e {id_segundo_lock} reservadas. ACESSO CONCEDIDO.")

        # Região Crítica (Comendo)
        self.realizar_operacao_io()

        # Libera recursos (ordem inversa não é obrigatória, mas é boa prática)
        interface_secundaria.release()
        interface_primaria.release()
        print(f"[Núcleo {self.id}] LIBERAÇÃO: Interfaces livres. Retomando cálculo.")

    def realizar_operacao_io(self):
        """Estado: Comendo"""
        print(f"[Núcleo {self.id}] >>> GRAVANDO DADOS (COMENDO) <<<")
        time.sleep(random.uniform(1, 2))

    def run(self):
        while True:
            self.computacao_ociosa()
            self.solicitar_acesso_io()

# --- BLOCO DE EXECUÇÃO (Faltava isso no seu exemplo) ---
if __name__ == "__main__":
    sistema = ControladorCluster()
    sistema.iniciar_cluster()